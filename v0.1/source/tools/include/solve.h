//
// Copyright 2023 Tobias Strauch, Munich, Bavaria
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
unsigned unsignedNumber2Unsigned (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* binOctHex2SBin (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
unsigned sbin2Unsigned_sub (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
unsigned sbin2Unsigned (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
int sbin2Int (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
bool sbin2Bool (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* cleanBin (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
bool chopZero (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
bool isZero (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
void twosCompl (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* compareEquation (NODE* aNode, NODE* bNode, unsigned id);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* shiftEquation (NODE* aNode, NODE* bNode, unsigned id);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* combEquation (NODE* aNode, 
                    NODE* bNode, 
                    unsigned id);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* logicalEquation (NODE* aNode, 
                       NODE* bNode, 
                       unsigned id);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* plusEquation (NODE* aNode, 
                    NODE* bNode);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* minusEquation (NODE* aNode, 
                     NODE* bNode);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* multEquation (NODE* aNode, 
                    NODE* bNode);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* powerEquation (NODE* aNode, 
                     NODE* bNode);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* divModEquation (NODE* aNode, NODE* bNode, unsigned id);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* incDecEquation (NODE* aNode, 
                      unsigned id);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* decEquation (NODE* aNode);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* concatEquation (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* unaryConstant2SBin (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
unsigned getPrecedence (unsigned operatorId);
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
NODE* solvePrecedenceEquation (NODE* node, 
                               NODE* bSubNode);
/////////////////////////////////////////////////////////////////////////////////
/// Solves the expression of the given NODE.
/// Returns NULL when solving not successful.
/////////////////////////////////////////////////////////////////////////////////
NODE* solveEquation (NODE* node);

//
// Copyright 2023 Tobias Strauch, Munich, Bavaria
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//

//////////////////////////////////////////////////////////////////////////////////////
/// Returns a new node with given id.
/////////////////////////////////////////////////////////////////////////////////
NODE* initNode (unsigned id);
/////////////////////////////////////////////////////////////////////////////////
/// Returns a new node with given id at the sub node of the give node.
/////////////////////////////////////////////////////////////////////////////////
NODE* initSubNode (NODE* node, 
                   unsigned id);
/////////////////////////////////////////////////////////////////////////////////
///	Initializes a new node with the given id and links it as sub node 
/// to the given node.
/// Returns the new node.
/////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
/// Returns a new node with given id at the next node of the give node.
/////////////////////////////////////////////////////////////////////////////////
NODE* initNextNode (unsigned id, 
                    NODE *node);
/////////////////////////////////////////////////////////////////////////////////
///	Initializes a new node with the given id and links it as sub node 
/// to the given node.
/////////////////////////////////////////////////////////////////////////////////
void insertNode (NODE *node, 
                 unsigned id);
/////////////////////////////////////////////////////////////////////////////////
/// Parses the given tree and returns first node that matches given id.
/// If no node is found, then it returns NULL.
/////////////////////////////////////////////////////////////////////////////////
NODE* getNode (NODE* node, 
               unsigned id);
/////////////////////////////////////////////////////////////////////////////////
/// Parses the given tree only one the level of the given NODE 
/// and returns first node that matches given id.
/// If no NODE is found then it returns NULL.
/////////////////////////////////////////////////////////////////////////////////
NODE* getNodeThisLevel (NODE* node, 
                        unsigned id);
/////////////////////////////////////////////////////////////////////////////////
/// Parses the given tree only one sub level of the given NODE 
/// and returns first node that matches given id.
/// If no NODE is found then it returns NULL.
/////////////////////////////////////////////////////////////////////////////////
NODE* getNodeSubLevel (NODE* node, 
                       unsigned id);
/////////////////////////////////////////////////////////////////////////////////
/// Finds all nodes with the given id in a tree and adds them to the return list
/////////////////////////////////////////////////////////////////////////////////
void getNodes (unsigned id, 
               NODE *sourceNode, 
               NODE *returnNode);
/////////////////////////////////////////////////////////////////////////////////
/// Changes the id of all nodes in a tree with the given from id to 
/// the given to id.
/////////////////////////////////////////////////////////////////////////////////
void modifyNode (NODE* node, 
                 unsigned fromID, 
                 unsigned toID);
/////////////////////////////////////////////////////////////////////////////////
/// Converts a node into a string.
/////////////////////////////////////////////////////////////////////////////////
string node2String (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
/// Parses a list of a given node list and returns integer value.
/////////////////////////////////////////////////////////////////////////////////
int string2Int (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
/// Check if string is number
///////////////////////////////////////////////////////////////////////////////// 
bool is_number (const string &s);
/////////////////////////////////////////////////////////////////////////////////
/// Compares two given trees. Return true if they are identical.
/////////////////////////////////////////////////////////////////////////////////
bool checkTree (NODE* treeA, 
                NODE* treeB);
/////////////////////////////////////////////////////////////////////////////////
/// Checks if a string is presented as a branch in tree. 
/// Updates subNode if branch found and sub node exists.
/////////////////////////////////////////////////////////////////////////////////
bool checkTree (string &name, 
                string &header, 
                NODE* tree, 
                NODE* subNode);
/////////////////////////////////////////////////////////////////////////////////
/// Calls checkTree with the same parameters and a new header.
/////////////////////////////////////////////////////////////////////////////////
bool checkTree (string &name, 
                NODE* tree);
/////////////////////////////////////////////////////////////////////////////////
/// Checks if the SI list testTreeNode is included in the tree inTreeNode.
/////////////////////////////////////////////////////////////////////////////////
bool checkSITree (NODE* testTreeNode, 
                  NODE* inTreeNode);
/////////////////////////////////////////////////////////////////////////////////
/// The function parses the given tree (starting from node), until it finds 
/// an identifier node. Starting from there it inserts the given SI list into 
/// the "tree". 
/// The resulting nodes on each level are ordered. 
/// It adds a node with the id 0 at the end of each branch.
/// The node origNode (can be NULL) is added as sub below the 0 identifier node.
/////////////////////////////////////////////////////////////////////////////////
void addSITree (NODE* node, 
                NODE* origNode, 
                NODE* tree);
/////////////////////////////////////////////////////////////////////////////////
/// Converts the given string into an SI node and calls addSITree with it.
/////////////////////////////////////////////////////////////////////////////////
void addSITree (string &name, 
                NODE* subTree, 
                NODE* tree);
/////////////////////////////////////////////////////////////////////////////////
/// Converts the given string into an SI node and calls addSITree with it.
/// Passes NULL as sub-tree.
/////////////////////////////////////////////////////////////////////////////////
void addSITree (string &name, 
                NODE* tree);
/////////////////////////////////////////////////////////////////////////////////
/// Returns a hell of a copy of the given tree.
/////////////////////////////////////////////////////////////////////////////////
NODE* copyTree (NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Returns a copy of a given tree w/o the -> next subbranch of the 
/// given top node.
/////////////////////////////////////////////////////////////////////////////////
NODE* copyTreeNoNext (NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Merges aTree into resultTree.
/// If aTree has a 0 identifier node, it continues merging, when 
/// parameter passZero is true.
/////////////////////////////////////////////////////////////////////////////////
void mergeTrees (bool passZero, 
                 NODE* aTree, 
                 NODE* resultTree);
/////////////////////////////////////////////////////////////////////////////////
/// Calls mergeTrees with passZero parameter set to false
/////////////////////////////////////////////////////////////////////////////////
void mergeTrees (NODE* aTree, 
                 NODE* resultTree);
/////////////////////////////////////////////////////////////////////////////////
/// Merges aTree and bTree to generate resultTree.
/////////////////////////////////////////////////////////////////////////////////
void mergeTrees (NODE* aTree, 
                 NODE* bTree, 
                 NODE* resultTree);
/////////////////////////////////////////////////////////////////////////////////
/// Merge fromNode into toNode.
/////////////////////////////////////////////////////////////////////////////////
void mergeSITrees (NODE* fromNode, 
                   NODE* toNode);
/////////////////////////////////////////////////////////////////////////////////
/// Merge fromNode into toNode.
/////////////////////////////////////////////////////////////////////////////////
void mergeSITreesSubList (NODE* fromNode, 
                          NODE* toNode);
/////////////////////////////////////////////////////////////////////////////////
///	Deletes the given tree, including top level node.
/////////////////////////////////////////////////////////////////////////////////
void deleteTree (NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Counts the number of autumn leaves of a tree.
/////////////////////////////////////////////////////////////////////////////////
unsigned countTreeLeaves (NODE* aTree);
/////////////////////////////////////////////////////////////////////////////////
/// Finds the shortest branch and removes other branches at the same time.
/// Returns branch depth or -1 when shortest branch length not unique.
/////////////////////////////////////////////////////////////////////////////////
int chopTree (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
/// Checks if a tree in the form of a list is covered in the tree.
/////////////////////////////////////////////////////////////////////////////////
bool listCoveredInTree (NODE* node, 
                        NODE* tree, 
                        bool passTrueExactFalse);
/////////////////////////////////////////////////////////////////////////////////
/// Checks if a tree in the form of a list is covered in the tree.
/////////////////////////////////////////////////////////////////////////////////
bool listCoveredInTree (NODE* node, 
                        NODE* tree);
/////////////////////////////////////////////////////////////////////////////////
/// Counts all first 0 nodes of a given tree.
/////////////////////////////////////////////////////////////////////////////////
unsigned countSITree (NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Counts all first 0 nodes of a given tree.
/////////////////////////////////////////////////////////////////////////////////
unsigned countSITree (NODE *node, 
                      unsigned level);
/////////////////////////////////////////////////////////////////////////////////
/// Counts all first 0 nodes of a given tree.
/////////////////////////////////////////////////////////////////////////////////
unsigned countSITreeLinked (NODE *node, 
                            unsigned level);
/////////////////////////////////////////////////////////////////////////////////
/// Return depth of SI-tree by counting zeros
/////////////////////////////////////////////////////////////////////////////////
unsigned getDepth (NODE* aNode);
/////////////////////////////////////////////////////////////////////////////////
/// Return distance of two nodes 
/////////////////////////////////////////////////////////////////////////////////
int getDist (NODE* aNode, 
             NODE* bNode);
/////////////////////////////////////////////////////////////////////////////////
/// Replaces the list of all G_SI nodes with a new list of the given string.
/////////////////////////////////////////////////////////////////////////////////
void replaceSI (NODE* node, 
                string &newString);
/////////////////////////////////////////////////////////////////////////////////
/// Return the simple identifier string for the first relevant node 
/// in the given tree.
/////////////////////////////////////////////////////////////////////////////////
string getSI (NODE* node);
/////////////////////////////////////////////////////////////////////////////////
/// Search the SI tree of the given node based on an SI string
/// and return its sub node if found.
/////////////////////////////////////////////////////////////////////////////////
NODE* getTree (string &header, string signal, NODE* node);
/////////////////////////////////////////////////////////////////////////////////
/// Search the SI tree of the given node based on an SI
/// and return its sub node if found.
/////////////////////////////////////////////////////////////////////////////////
NODE* getSubTree (string &name, 
                  NODE* tree);
/////////////////////////////////////////////////////////////////////////////////
/// Search the SI tree of the given node based on an node
/// and return its sub node if found.
/////////////////////////////////////////////////////////////////////////////////
NODE* getSITreeNode (NODE* cmpNode, NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Skip "level" number 0 identifiers within a tree.
/// Then call getSITreeNode w/o level parameter.
/// Continue as long as the called getSITreeNode function returns a valid node.
/////////////////////////////////////////////////////////////////////////////////
NODE* getSITreeNode (unsigned level, 
                     NODE* cmpNode, 
                     NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Prints database tree.
/// Adds debug information for some key ids when appendInfo is set.
/// Beyond certain ids the string is printed.
/////////////////////////////////////////////////////////////////////////////////
void printTree (int level, 
                int max, 
                bool appendInfo, 
                NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Calls printTree and sets appendInfo.
/////////////////////////////////////////////////////////////////////////////////
void printTree (int level, 
                int max, 
                NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Calls printTree and sets appendInfo.
/////////////////////////////////////////////////////////////////////////////////
void printTree (int level, 
                NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Calls printTree and adds unlimited level parameters and sets appendInfo.
/////////////////////////////////////////////////////////////////////////////////
void printTree (NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Converts the SI tree into string and prints them.
/// Followed by individual subtrees when printSub is set.
/////////////////////////////////////////////////////////////////////////////////
void printSITree (string &header, 
                  bool printSub, 
                  NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Converts the SI tree into string and prints them.
/// Followed by "." and a second  printSITree call when printSub is set.
/////////////////////////////////////////////////////////////////////////////////
void printSITree (string &header, 
                  bool printSub, 
                  bool skip, 
                  bool skipThis, 
                  NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Calls printSITree and sets printSub to false.
/////////////////////////////////////////////////////////////////////////////////
void printSITree (string &header, 
                  NODE *node);
/////////////////////////////////////////////////////////////////////////////////
/// Calls printSITree and adds a header string and sets printSub to false.
/////////////////////////////////////////////////////////////////////////////////
void printSITree (NODE *node);
